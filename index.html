<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Steganography Text Encoder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fc;
        }

        .container-card {
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 0px 10px -5px rgba(0, 0, 0, 0.04);
        }

        .loading-ring {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #3b82f6;
            width: 1.5rem;
            height: 1.5rem;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="p-4 sm:p-8 min-h-screen flex items-start justify-center">

    <div id="app" class="w-full max-w-3xl container-card bg-white rounded-xl p-6 sm:p-8 space-y-8 mt-10">
        <h1 class="text-3xl font-bold text-gray-800 border-b pb-4 mb-4">
            Lexical Steganography Encoder
        </h1>

        <!-- Input Section -->
        <section class="space-y-4">
            <label for="secretInput" class="block text-lg font-medium text-gray-700">
                Secret Message (Characters will be encoded)
            </label>
            <input type="text" id="secretInput" value="I am good"
                class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 text-gray-800"
                placeholder="Enter text to encode (e.g., hello)">

            <button id="encodeButton"
                class="w-full sm:w-auto px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition duration-150 flex items-center justify-center"
                onclick="handleEncode()">
                <span id="buttonText">Encode Message</span>
                <div id="loadingIndicator" class="loading-ring hidden ml-3"></div>
            </button>
            <div id="statusMessage" class="text-sm text-red-600 mt-2 hidden"></div>
        </section>

        <!-- Output Section -->
        <section class="space-y-4 pt-4 border-t">
            <h2 class="text-xl font-semibold text-gray-800">1. Encoded Cover Text</h2>
            <div id="coverTextOutput"
                class="min-h-12 p-4 bg-gray-50 border border-gray-200 rounded-lg text-gray-800 whitespace-pre-wrap select-all">
                The resulting sentence will appear here.
            </div>

            <h2 class="text-xl font-semibold text-gray-800 pt-4">2. Decoded Verification</h2>
            <div id="decodedVerification"
                class="min-h-12 p-4 bg-gray-50 border border-gray-200 rounded-lg text-green-700 font-mono">
                Decoded message verification (first letter of each word).
            </div>
        </section>
    </div>

    <script>
        const BEAM_WIDTH = 20;
        const FALLBACK_PENALTY = -20.0; // Heavy penalty for using a non-bigram word

        let model = null;
        let wordsByChar = {}; // Used for the first word and fallback mechanism

        const secretInput = document.getElementById('secretInput');
        const encodeButton = document.getElementById('encodeButton');
        const buttonText = document.getElementById('buttonText');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const statusMessage = document.getElementById('statusMessage');
        const coverTextOutput = document.getElementById('coverTextOutput');
        const decodedVerification = document.getElementById('decodedVerification');

        /**
         * Loads the N-Gram model data from the JSON file.
         */
        async function loadModel() {
            try {
                const response = await fetch('model_data.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();

                // --- Data Processing for Efficiency ---
                model = {
                    vocab: data.vocab,
                    map: data.map // This is the transition graph: { 'current_id': { 'char': [next_ids] } }
                };

                // Create the fallback structure: { 'a': [id1, id2, ...], 'b': [...] }
                model.vocab.forEach((word, id) => {
                    const char = word[0];
                    if (!wordsByChar[char]) {
                        wordsByChar[char] = [];
                    }
                    wordsByChar[char].push(id);
                });

                console.log(`Model loaded successfully. Vocab size: ${model.vocab.length}`);
                return true;

            } catch (error) {
                console.error("Error loading model:", error);
                statusMessage.textContent = "Error: Could not load model_data.json. Check console.";
                statusMessage.classList.remove('hidden');
                encodeButton.disabled = true;
                return false;
            }
        }

        /**
         * Cleans the secret text to get the sequence of target characters.
         * @param {string} text - The input text.
         * @returns {string[]} An array of lowercase characters.
         */
        function getTargetChars(text) {
            return text.toLowerCase().replace(/[^a-z]/g, '').split('');
        }

        /**
         * Finds valid next words using the Beam Search algorithm.
         * @param {number} currentWordId - ID of the last word in the path.
         * @param {string} targetChar - The required starting letter of the next word.
         * @returns {Array<[number, number]>} List of [next_word_id, log_probability_score].
         */
        function getCandidates(currentWordId, targetChar) {
            const currentIdStr = String(currentWordId);
            const candidates = [];

            // Strategy A: Look at the N-Gram Graph (Coherent transition)
            const transitions = model.map[currentIdStr];
            if (transitions && transitions[targetChar]) {
                // The JSON only stores the IDs, not the probabilities.
                // We assume the first word in the list is the most probable (highest score),
                // and assign a simple descending score sequence.
                const ids = transitions[targetChar];
                const baseScore = 0.0;
                ids.forEach((id, index) => {
                    // Assign a slightly lower score for less likely options
                    const score = baseScore - (index * 0.1);
                    candidates.push([id, score]);
                });
            }

            // Strategy B: Fallback (If Strategy A found nothing or is first word)
            if (candidates.length === 0) {
                const fallbackWords = wordsByChar[targetChar] || [];
                // Apply a heavy penalty for breaking grammatical flow
                fallbackWords.slice(0, 5).forEach(wordId => {
                    candidates.push([wordId, FALLBACK_PENALTY]);
                });
            }

            return candidates;
        }

        /**
         * Implements the Beam Search to find the best-scoring sentence.
         * @param {string[]} targetChars - Sequence of required starting characters.
         * @returns {string} The encoded sentence.
         */
        function encodeText(targetChars) {
            if (!targetChars || targetChars.length === 0) return "";

            // Step 1: Initialize Beam with the first character
            const firstChar = targetChars[0];
            let beam = [];

            // Get initial candidates (uses fallback logic implicitly)
            const startCandidates = wordsByChar[firstChar] || [];
            startCandidates.slice(0, BEAM_WIDTH).forEach(w_id => {
                beam.push({
                    sequence: [w_id],
                    score: 0.0 // Start score is zero
                });
            });

            // Step 2: Iterate through the rest of the characters
            for (let char_idx = 1; char_idx < targetChars.length; char_idx++) {
                const targetChar = targetChars[char_idx];
                let newBeam = [];

                for (const path of beam) {
                    const lastWordId = path.sequence[path.sequence.length - 1];
                    const currentScore = path.score;

                    const candidates = getCandidates(lastWordId, targetChar);

                    for (const [nextWordId, transScore] of candidates) {
                        newBeam.push({
                            sequence: [...path.sequence, nextWordId],
                            score: currentScore + transScore
                        });
                    }
                }

                // Pruning: Sort by score (descending) and keep top K
                if (newBeam.length === 0) {
                    // This happens if NO word could be found for the character (very rare)
                    console.warn(`Dead end at character: ${targetChar}`);
                    break;
                }

                newBeam.sort((a, b) => b.score - a.score);
                beam = newBeam.slice(0, BEAM_WIDTH);
            }

            // Step 3: Return best sentence
            if (beam.length === 0) return "Encoding failed: No valid path found.";

            const bestPath = beam[0];
            const decodedWords = bestPath.sequence.map(id => model.vocab[id]);

            // Capitalize first letter and add a period for style
            const sentence = decodedWords.join(" ");
            return sentence.charAt(0).toUpperCase() + sentence.slice(1) + ".";
        }

        /**
         * Decodes the cover text back into the secret message.
         * @param {string} sentence - The encoded sentence.
         * @returns {string} The decoded message.
         */
        function decodeText(sentence) {
            const words = sentence.toLowerCase().match(/[a-z]+/g) || [];
            return words.map(w => w[0]).join('');
        }

        /**
         * Main handler for the encode button click.
         */
        async function handleEncode() {
            if (!model) {
                // Should only happen if initial load fails
                statusMessage.textContent = "Model not ready. Please refresh.";
                return;
            }

            const secret = secretInput.value.trim();
            if (secret.length === 0) {
                statusMessage.textContent = "Please enter a secret message.";
                statusMessage.classList.remove('hidden');
                return;
            }

            statusMessage.classList.add('hidden');
            encodeButton.disabled = true;
            buttonText.textContent = "Encoding...";
            loadingIndicator.classList.remove('hidden');

            const targetChars = getTargetChars(secret);

            // Execute encoding (use setTimeout to allow UI to update loading state)
            setTimeout(() => {
                const coverText = encodeText(targetChars);
                const decodedText = decodeText(coverText);

                coverTextOutput.textContent = coverText;
                decodedVerification.textContent = `Original: ${targetChars.join('')} | Decoded: ${decodedText}`;

                if (targetChars.join('') === decodedText) {
                    decodedVerification.classList.remove('text-red-700');
                    decodedVerification.classList.add('text-green-700');
                } else {
                    decodedVerification.classList.remove('text-green-700');
                    decodedVerification.classList.add('text-red-700');
                    console.error("Decoding error! Check if the corpus has enough transition data.");
                }

                encodeButton.disabled = false;
                buttonText.textContent = "Encode Message";
                loadingIndicator.classList.add('hidden');
            }, 10);
        }

        // --- Initialization ---
        window.onload = async () => {
            const success = await loadModel();
            if (success) {
                encodeButton.disabled = false;
                // Run a test encoding on load for initial display
                handleEncode();
            }
        };

    </script>
</body>

</html>